import { LUTData } from '../types/color';
import { Adjustments } from '../types/adjustments';
import JSZip from 'jszip';
import { applyAdjustmentsAI } from './colorGrading';

// Enhanced LUT generation with adjustments
export function generateCubeLUT(lutData: LUTData, adjustments?: Adjustments): string {
  const { size, data } = lutData;
  let content = `# Generated by LUT Generator Pro\n`;
  content += `# Adjustments: ${JSON.stringify(adjustments || {})}\n`;
  content += `LUT_3D_SIZE ${size}\n\n`;

  for (let b = 0; b < size; b++) {
    for (let g = 0; g < size; g++) {
      for (let r = 0; r < size; r++) {
        let rgb = data[b][g][r];
        
        // Apply adjustments if provided
        if (adjustments) {
          const adjustedColor = applyColorAdjustments(rgb, adjustments);
          rgb = {
            r: adjustedColor.r,
            g: adjustedColor.g,
            b: adjustedColor.b
          };
        }

        content += `${rgb.r.toFixed(6)} ${rgb.g.toFixed(6)} ${rgb.b.toFixed(6)}\n`;
      }
    }
  }

  return content;
}

export function generate3dlLUT(lutData: LUTData, adjustments?: Adjustments): string {
  const { size, data } = lutData;
  let content = `# Generated by LUT Generator Pro\n`;
  content += `# Adjustments: ${JSON.stringify(adjustments || {})}\n`;
  content += `3DMESH\nMeshes ${size} ${size} ${size}\n\n`;

  for (let b = 0; b < size; b++) {
    for (let g = 0; g < size; g++) {
      for (let r = 0; r < size; r++) {
        let rgb = data[b][g][r];
        
        // Apply adjustments if provided
        if (adjustments) {
          const adjustedColor = applyColorAdjustments(rgb, adjustments);
          rgb = {
            r: adjustedColor.r,
            g: adjustedColor.g,
            b: adjustedColor.b
          };
        }

        content += `${Math.round(rgb.r * 1023)} ${Math.round(rgb.g * 1023)} ${Math.round(rgb.b * 1023)}\n`;
      }
    }
  }

  return content;
}

export function generateLookLUT(lutData: LUTData, adjustments?: Adjustments): string {
  const { size, data } = lutData;
  const metadata = {
    creator: "LUT Generator Pro",
    created: new Date().toISOString(),
    description: "Custom color grading LUT",
    format: "3D",
    size: size,
    adjustments: adjustments || {}
  };

  // Create a deep copy of data to avoid mutation
  const processedData = JSON.parse(JSON.stringify(data));

  // Apply adjustments to LUT data
  if (adjustments) {
    for (let b = 0; b < size; b++) {
      for (let g = 0; g < size; g++) {
        for (let r = 0; r < size; r++) {
          const adjustedColor = applyColorAdjustments(processedData[b][g][r], adjustments);
          processedData[b][g][r] = adjustedColor;
        }
      }
    }
  }

  let content = JSON.stringify({
    metadata,
    lut: processedData
  }, null, 2);

  return content;
}

export async function createLUTZipFile(
  lutData: LUTData, 
  adjustments?: Adjustments
): Promise<Blob> {
  const zip = new JSZip();
  
  // Add different LUT formats to the zip with adjustments
  zip.file("lut.cube", generateCubeLUT(lutData, adjustments));
  zip.file("lut.3dl", generate3dlLUT(lutData, adjustments));
  zip.file("lut.look", generateLookLUT(lutData, adjustments));
  
  // Add readme with adjustment details
  zip.file("README.txt", 
    "LUT Generator Pro - Custom Color Grading LUT\n\n" +
    "This package contains your custom LUT in multiple formats:\n\n" +
    "- lut.cube: Industry standard format (DaVinci Resolve, Adobe products)\n" +
    "- lut.3dl: High-end color grading format\n" +
    "- lut.look: Advanced format with metadata\n\n" +
    `Adjustments Applied: ${JSON.stringify(adjustments || {}, null, 2)}\n\n` +
    "Generated on: " + new Date().toLocaleString()
  );
  
  return await zip.generateAsync({ type: "blob" });
}

// Helper function to apply color adjustments
function applyColorAdjustments(
  rgb: { r: number; g: number; b: number }, 
  adjustments: Adjustments
): { r: number; g: number; b: number } {
  // Convert RGB to ImageData for adjustment
  const imageData = new ImageData(new Uint8ClampedArray([
    Math.round(rgb.r * 255),
    Math.round(rgb.g * 255),
    Math.round(rgb.b * 255),
    255
  ]), 1, 1);

  // Apply adjustments
  const adjustedImageData = applyAdjustmentsAI(imageData, adjustments);

  // Convert back to normalized RGB
  return {
    r: adjustedImageData.data[0] / 255,
    g: adjustedImageData.data[1] / 255,
    b: adjustedImageData.data[2] / 255
  };
}